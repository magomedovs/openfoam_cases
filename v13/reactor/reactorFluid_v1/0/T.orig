/*--------------------------------*- C++ -*----------------------------------*\
  =========                 |
  \\      /  F ield         | OpenFOAM: The Open Source CFD Toolbox
   \\    /   O peration     | Website:  https://openfoam.org
    \\  /    A nd           | Version:  13
     \\/     M anipulation  |
\*---------------------------------------------------------------------------*/
FoamFile
{
    format      ascii;
    class       volScalarField;
    location    "0";
    object      T;
}
// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

dimensions      [0 0 0 1 0 0 0];

// internalField   uniform 298;
internalField #codeStream
{
    code
    #{        
        const IOdictionary& d = static_cast<const IOdictionary&>(dict);
        const fvMesh& mesh = refCast<const fvMesh>(d.db());
        scalarField fld(mesh.nCells(), 0);

        // std::system("echo $FOAM_CASE");
        #include "0/Tbc.H"

        forAll(fld, i)
        {
            const scalar z = mesh.C()[i][2];

            fld[i] = Tbc(z);

            // fld[i] = 273 + 63;
            // fld[i] = 273 + 95;

            // if ((z >= z_heating_min) && (z <= z_heating_max))
            // {
            //     field[faceI] = Tmax;
            // }

            // if (z >= 0.2)
            // {
            //     fld[i] = 273 + 95;
            // }
            // else
            // {
            //     fld[i] = 273 + 25;
            // }
        }

        writeEntry(os, "", fld);
    #};

    codeInclude
    #{
        #include "volFields.H"
        #include <vector>
    #};

    codeOptions
    #{
        -I$(LIB_SRC)/finiteVolume/lnInclude \
        -I$(LIB_SRC)/meshTools/lnInclude \
        -I$(FOAM_CASE)
    #};

    codeLibs
    #{
        -lmeshTools \
        -lfiniteVolume
    #};
};

boundaryField
{
    inlet
    {
        type            fixedValue;
        // value           $internalField;
        value           uniform #calc "273 + 63";

        // type            zeroGradient;
    }

    outlet
    {

        // type            waveTransmissive;  // Non-reflective for compressible flow
        // gamma           1.4;              // Heat capacity ratio (Cp/Cv)
        // field           T;            // Act on T
        // value           uniform #calc "273 + 95";        // Reference value 
        // value           uniform #calc "273 + 25";        // Reference value 
        
        // type            advective;
        // lInf            5;
        // fieldInf        #calc "273";
        
        // type            inletOutlet;
        // inletValue      uniform #calc "273 + 95";
        // value           uniform #calc "273 + 95";
        // inletValue      $internalField;
        // value           $internalField;
        // inletValue      uniform #calc "273 + 750";
        // value           uniform #calc "273 + 750";
        
        // type            fixedValue;
        // value           uniform #calc "273 + 95";

        type            zeroGradient;
    }

    pipe
    {
        // type            fixedValue;
        // value           uniform     298;

        type    codedFixedValue;
        value   uniform 298;
        name    middleHeating;   // name of generated BC

        code
        #{
            // operator==(min(10, 0.1*this->db().time().value()));

            const fvPatch& boundaryPatch = patch();
            const vectorField& Cf = boundaryPatch.Cf();
            scalarField& field = *this;

            #include "0/Tbc.H"
           
            forAll(Cf, faceI)
            {
                const scalar z = Cf[faceI].z();

                field[faceI] = Tbc(z);

                // field[faceI] = heatingFunc(z);

                // if ((z >= z_heating_min) && (z <= z_heating_max))
                // {
                //     field[faceI] = Tmax;
                // }

                // if (z >= 0.2)
                // {
                //     field[faceI] = 298 + 30;
                // }
            }             

        #};

        codeInclude
        #{
            #include <vector>
        #};

        codeOptions
        #{
            -I$(LIB_SRC)/finiteVolume/lnInclude \
            -I$(FOAM_CASE)
        #};
    }

}


// ************************************************************************* //
